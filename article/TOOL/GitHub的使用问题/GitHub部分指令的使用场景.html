<!DOCTYPE html>
    <html lang="zh-CN">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub部分指令的使用场景</title>
    <style>
      body {
        background: linear-gradient(
          90deg,
          #e0f2ff 0%,
          #f8fafc 40%,
          #f8fafc 60%,
          #e0f2ff 100%
        );
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
        color: #333;
      }
      h1 {
        color: #222;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.5rem;
        text-align: center;
        font-size: 2.5rem;
      }
      h2,
      h3 {
        color: #222;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.5rem;
      }
      p {
        text-indent: 2em; 
      }
      pre {
        background: #f5f5f5;
        padding: 1rem;
        border-radius: 4px;
        overflow-x: auto;
      }
      code {
        font-size: 1rem;
        background: #f5f5f5;
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
      }
      a {
        color: #007bff;
        text-decoration: none;
      }
      a:hover {
        text-decoration: none;
      }
      .back-link {
        margin-bottom: 2rem;
      }
      .back-btn {
        display: inline-block;
        padding: 0.5rem 1.2rem;
        background: linear-gradient(90deg, #4f8cff 0%, #38c6ff 100%);
        color: #fff;
        border: none;
        border-radius: 25px;
        font-size: 1rem;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(79, 140, 255, 0.12);
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s;
        text-decoration: none;
      }
      .back-btn:hover {
        background: linear-gradient(90deg, #38c6ff 0%, #4f8cff 100%);
        box-shadow: 0 4px 16px rgba(56, 198, 255, 0.18);
      }
      img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        display: block;
        margin: 0 auto;
      }
    </style>
    </head>
    <body>
    <div class="back-link">
    <a class="back-btn" href="../../../index.html">← 返回首页</a>
    </div>
    <article>
    <h1>git 部分场景操作指南</h1>
<p>GitHub 作为目前最流行的代码托管平台，其规范化使用确实能极大提升团队协作效率和个人开发体验。对于刚接触的开发者来说，命令繁多、场景复杂是常见痛点。本文将针对不同场景，详细讲解 GitHub 的核心操作。
初始化本地仓库将本地项目纳入 Git 管理并关联云端仓库，是使用 GitHub 的第一步，操作流程如下：</p>
<h2>初始化本地 Git 仓库,执行此命令后，文件夹中会生成隐藏的.git 目录（存储版本信息）：</h2>
<pre><code class="language-bash">git init
</code></pre>
<p>添加文件到暂存区,将项目文件纳入版本控制跟踪范围：</p>
<ul>
<li>添加单个文件</li>
</ul>
<pre><code class="language-bash">git add 文件名 #文件名一定要记得加后缀，另外如果你的文件中有放置其他文件也会一并添加
</code></pre>
<ul>
<li>添加所有文件（排除.gitignore 中指定的文件）</li>
</ul>
<pre><code class="language-bash">git add .
</code></pre>
<p>提交到本地仓库,用描述信息记录本次修改（建议清晰说明修改内容）：</p>
<pre><code class="language-bash">git commit -m &quot;需要添加的说明&quot;
</code></pre>
<p>关联远程仓库，先在 GitHub 上创建同名仓库（建议勾选 &quot;Add a README file&quot;），再关联本地仓库：</p>
<pre><code class="language-bash">git remote add origin https://github.com/你的用户名/仓库名.git
</code></pre>
<p>首次推送到云端
由于本地分支与远程分支尚未关联，需指定推送分支：</p>
<pre><code class="language-bash">git push -u origin main # main 为默认分支，部分仓库可能用 master，使用git第一次打开文件夹时你会发现名字时master
</code></pre>
<h2>一、本地仓库的更新较云端靠前</h2>
<p>（场景：本地已提交新修改，云端仓库未同步这些修改）</p>
<h3>1.此情况下我想保存本地修改</h3>
<p>直接将本地更新推送到云端即可，操作简单：</p>
<pre><code class="language-bash">git push origin 分支名 # 如 main 分支可省略分支名
</code></pre>
<h3>2.此情况下我想保存云端修改</h3>
<p>若云端有其他人提交的新内容（本地未同步），需先拉取云端更新并合并，再推送本地修改：</p>
<ul>
<li>拉取云端更新并自动合并到本地</li>
</ul>
<pre><code class="language-bash">git pull origin 分支名
</code></pre>
<ul>
<li>若拉取后无冲突，直接推送本地修改</li>
</ul>
<pre><code class="language-bash">git push origin 分支名
</code></pre>
<h3>3.此情况下我需要衡量一下保存我需要的部分</h3>
<p>当本地和云端修改有重叠（可能冲突），需手动选择保留内容：
先拉取云端更新，触发冲突提示：</p>
<pre><code class="language-bash">git pull origin 分支名
</code></pre>
<p>打开冲突文件（含&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 等标记），手动编辑保留需要的代码块
标记为已解决并提交：</p>
<pre><code class="language-bash">git add 冲突文件
git commit -m &quot;合并云端更新，保留本地核心修改&quot;
git push origin 分支名
</code></pre>
<h2>二、云端仓库的更新较本地靠前</h2>
<p>（场景：云端有新提交，本地未拉取这些更新）</p>
<h3>1.此情况下我想保存云端修改</h3>
<p>直接放弃本地未提交的修改，拉取云端更新覆盖本地：</p>
<ul>
<li>放弃本地所有未提交的修改（谨慎使用！）</li>
</ul>
<pre><code class="language-bash">git reset --hard HEAD
</code></pre>
<ul>
<li>拉取云端最新更新</li>
</ul>
<pre><code class="language-bash">git pull origin 分支名
</code></pre>
<h3>2.此情况下我需要衡量一下保存我需要的部分</h3>
<p>通过查看差异，选择性保留本地修改：
查看本地与云端的差异：</p>
<pre><code class="language-bash">git fetch origin # 拉取云端信息但不合并
git diff HEAD origin/分支名 # 对比本地与云端差异
</code></pre>
<p>把云端 fetch 来的分支和本地该分支合并</p>
<pre><code class="language-bash">git merge origin/分支名
</code></pre>
<p>将复制的代码片段粘贴回文件，提交并推送：</p>
<pre><code class="language-bash">git add .
git commit -m &quot;保留本地关键修改，同步云端更新&quot;
git push origin 分支名
</code></pre>
<h2>三、好像混沌了不知道怎么办</h2>
<p>（场景：本地状态混乱，冲突严重，分不清修改来源）</p>
<h3>1.此情况下我想保存本地修改</h3>
<p>用暂存功能保存所有本地修改，重建干净的工作区：</p>
<ul>
<li>暂存所有本地修改（包括未跟踪的新文件）</li>
</ul>
<pre><code class="language-bash">git stash -u # 暂存所有本地修改（包括未跟踪的新文件）
</code></pre>
<ul>
<li>拉取云端最新版本，覆盖本地,与上个步骤一样的警告慎用！</li>
</ul>
<pre><code class="language-bash">git reset --hard origin/分支名
</code></pre>
<ul>
<li>恢复暂存的本地修改，仍然需要手动整理</li>
</ul>
<pre><code class="language-bash">git stash pop
</code></pre>
<ul>
<li>整理后提交</li>
</ul>
<pre><code class="language-bash">git add .
git commit -m &quot;整理本地修改，基于云端最新版本提交&quot;
git push origin 分支名
</code></pre>
<h3>2.此情况下我想保存云端修改</h3>
<p>彻底放弃本地所有修改，强制同步云端版本：</p>
<ul>
<li>放弃本地所有修改和新增文件（极其谨慎！）</li>
</ul>
<pre><code class="language-bash">git clean -fd # 放弃所有未跟踪的文件和目录
git reset --hard origin/分支名
</code></pre>
<p>此情况下我需要衡量一下保存我需要的部分
通过对比历史版本，手动筛选需要保留的内容：
查看提交历史，找到需要参考的版本号：</p>
<pre><code class="language-bash">git log --oneline # 显示简洁的提交历史
</code></pre>
<p>用历史版本创建新分支，便于对比：</p>
<pre><code class="language-bash">git checkout -b temp-branch 版本号 # 基于历史版本创建临时分支
</code></pre>
<p>在临时分支与本地分支间手动对比文件，复制需要保留的内容，切换回原分支，整合内容后提交：</p>
<pre><code class="language-bash">git checkout 原分支名
git add .
git commit -m &quot;基于历史版本筛选并保留关键修改&quot;
git push origin 分支名 # 推送本地修改到云端
</code></pre>
<h2>其他小问题</h2>
<h3>为啥我的本地仓库和云端仓库的分支没有关联</h3>
<p><strong>原因</strong>：首次推送时未指定上游分支，或分支名在本地与云端不一致。</p>
<p><strong>解决方法</strong>：</p>
<pre><code>- 关联本地分支与云端分支（以 update 为例）

```bash
git branch --set-upstream-to=origin/远端分支名 本地分支名
# 也可以选择我把本地新分支推送到云端
git push -u origin 本地分支名 # 写出这行命令时它默认已经关联了本地所在分支和远程分支，如果远程没有则会新建
```

之后使用 git pull 或 git push 时就无需指定分支名了。为啥总提示 LF 错误？
</code></pre>
<p><strong>原因</strong>：不同操作系统的换行符格式不同（Windows 用 CRLF，Linux/Mac 用 LF），Git 默认会检查换行符一致性。</p>
<p><strong>解决方法</strong>：根据操作系统配置自动转换：</p>
<pre><code>- Windows 系统：提交时转换为 LF，拉取时转换为 CRLF

```bash
git config --global core.autocrlf true
```

- Linux/Mac 系统：提交时转换为 LF，拉取时不转换

```bash
git config --global core.autocrlf input
```
</code></pre>
<p>若需忽略特定文件的换行符检查，可在.gitignore 同级目录创建.gitattributes 文件，添加规则（如*.txt text eol=lf 强制指定文件使用 LF）。掌握这些操作后，无论是个人开发还是团队协作，都能更从容地应对 GitHub 的各种场景。记住：遇到混乱时，先通过 git status 查看当前状态，git log 查看历史记录，再逐步解决问题，避免盲目执行命令。</p>

    </article>
    </body>
    </html>