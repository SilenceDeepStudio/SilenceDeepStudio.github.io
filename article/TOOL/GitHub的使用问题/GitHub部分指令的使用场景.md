# git 部分场景操作指南

GitHub 作为目前最流行的代码托管平台，其规范化使用确实能极大提升团队协作效率和个人开发体验。对于刚接触的开发者来说，命令繁多、场景复杂是常见痛点。本文将针对不同场景，详细讲解 GitHub 的核心操作。
初始化本地仓库将本地项目纳入 Git 管理并关联云端仓库，是使用 GitHub 的第一步，操作流程如下：

## 初始化本地 Git 仓库,执行此命令后，文件夹中会生成隐藏的.git 目录（存储版本信息）：

```bash
git init
```

添加文件到暂存区,将项目文件纳入版本控制跟踪范围：

- 添加单个文件

```bash
git add 文件名 #文件名一定要记得加后缀，另外如果你的文件中有放置其他文件也会一并添加
```

- 添加所有文件（排除.gitignore 中指定的文件）

```bash
git add .
```

提交到本地仓库,用描述信息记录本次修改（建议清晰说明修改内容）：

```bash
git commit -m "需要添加的说明"
```

关联远程仓库，先在 GitHub 上创建同名仓库（建议勾选 "Add a README file"），再关联本地仓库：

```bash
git remote add origin https://github.com/你的用户名/仓库名.git
```

首次推送到云端
由于本地分支与远程分支尚未关联，需指定推送分支：

```bash
git push -u origin main # main 为默认分支，部分仓库可能用 master，使用git第一次打开文件夹时你会发现名字时master
```

## 一、本地仓库的更新较云端靠前

（场景：本地已提交新修改，云端仓库未同步这些修改）

### 1.此情况下我想保存本地修改

直接将本地更新推送到云端即可，操作简单：

```bash
git push origin 分支名 # 如 main 分支可省略分支名
```

### 2.此情况下我想保存云端修改

若云端有其他人提交的新内容（本地未同步），需先拉取云端更新并合并，再推送本地修改：

- 拉取云端更新并自动合并到本地

```bash
git pull origin 分支名
```

- 若拉取后无冲突，直接推送本地修改

```bash
git push origin 分支名
```

### 3.此情况下我需要衡量一下保存我需要的部分

当本地和云端修改有重叠（可能冲突），需手动选择保留内容：
先拉取云端更新，触发冲突提示：

```bash
git pull origin 分支名
```

打开冲突文件（含<<<<<<< HEAD 等标记），手动编辑保留需要的代码块
标记为已解决并提交：

```bash
git add 冲突文件
git commit -m "合并云端更新，保留本地核心修改"
git push origin 分支名
```

## 二、云端仓库的更新较本地靠前

（场景：云端有新提交，本地未拉取这些更新）

### 1.此情况下我想保存云端修改

直接放弃本地未提交的修改，拉取云端更新覆盖本地：

- 放弃本地所有未提交的修改（谨慎使用！）

```bash
git reset --hard HEAD
```

- 拉取云端最新更新

```bash
git pull origin 分支名
```

### 2.此情况下我需要衡量一下保存我需要的部分

通过查看差异，选择性保留本地修改：
查看本地与云端的差异：

```bash
git fetch origin # 拉取云端信息但不合并
git diff HEAD origin/分支名 # 对比本地与云端差异
```

把云端 fetch 来的分支和本地该分支合并

```bash
git merge origin/分支名
```

将复制的代码片段粘贴回文件，提交并推送：

```bash
git add .
git commit -m "保留本地关键修改，同步云端更新"
git push origin 分支名
```

## 三、好像混沌了不知道怎么办

（场景：本地状态混乱，冲突严重，分不清修改来源）

### 1.此情况下我想保存本地修改

用暂存功能保存所有本地修改，重建干净的工作区：

- 暂存所有本地修改（包括未跟踪的新文件）

```bash
git stash -u # 暂存所有本地修改（包括未跟踪的新文件）
```

- 拉取云端最新版本，覆盖本地,与上个步骤一样的警告慎用！

```bash
git reset --hard origin/分支名
```

- 恢复暂存的本地修改，仍然需要手动整理

```bash
git stash pop
```

- 整理后提交

```bash
git add .
git commit -m "整理本地修改，基于云端最新版本提交"
git push origin 分支名
```

### 2.此情况下我想保存云端修改

彻底放弃本地所有修改，强制同步云端版本：

- 放弃本地所有修改和新增文件（极其谨慎！）

```bash
git clean -fd # 放弃所有未跟踪的文件和目录
git reset --hard origin/分支名
```

此情况下我需要衡量一下保存我需要的部分
通过对比历史版本，手动筛选需要保留的内容：
查看提交历史，找到需要参考的版本号：

```bash
git log --oneline # 显示简洁的提交历史
```

用历史版本创建新分支，便于对比：

```bash
git checkout -b temp-branch 版本号 # 基于历史版本创建临时分支
```

在临时分支与本地分支间手动对比文件，复制需要保留的内容，切换回原分支，整合内容后提交：

```bash
git checkout 原分支名
git add .
git commit -m "基于历史版本筛选并保留关键修改"
git push origin 分支名 # 推送本地修改到云端
```

## 其他小问题

### 为啥我的本地仓库和云端仓库的分支没有关联

**原因**：首次推送时未指定上游分支，或分支名在本地与云端不一致。

**解决方法**：

    - 关联本地分支与云端分支（以 update 为例）

    ```bash
    git branch --set-upstream-to=origin/远端分支名 本地分支名
    # 也可以选择我把本地新分支推送到云端
    git push -u origin 本地分支名 # 写出这行命令时它默认已经关联了本地所在分支和远程分支，如果远程没有则会新建
    ```

    之后使用 git pull 或 git push 时就无需指定分支名了。为啥总提示 LF 错误？

**原因**：不同操作系统的换行符格式不同（Windows 用 CRLF，Linux/Mac 用 LF），Git 默认会检查换行符一致性。

**解决方法**：根据操作系统配置自动转换：

    - Windows 系统：提交时转换为 LF，拉取时转换为 CRLF

    ```bash
    git config --global core.autocrlf true
    ```

    - Linux/Mac 系统：提交时转换为 LF，拉取时不转换

    ```bash
    git config --global core.autocrlf input
    ```

若需忽略特定文件的换行符检查，可在.gitignore 同级目录创建.gitattributes 文件，添加规则（如\*.txt text eol=lf 强制指定文件使用 LF）。掌握这些操作后，无论是个人开发还是团队协作，都能更从容地应对 GitHub 的各种场景。记住：遇到混乱时，先通过 git status 查看当前状态，git log 查看历史记录，再逐步解决问题，避免盲目执行命令。

```

```
